# DATA-STRUCTURES-AND-ALGORITHMS
資料結構與演算法課程之學習紀錄，包含筆記整理、學習歷程和程式碼等。

## 自我介紹
姓名：吳家瑩\
學校：東吳大學\
主修：哲學系、巨量資料管理學院學士學位\
輔修：金融科技學程\
E-mail：05113009@gm.scu.edu.tw

## 課程心得
在上這堂課之前，我其實還沒有正式學過python，因為是雙主修生，所以即使基礎課程還沒修也不會擋修這堂課，也因為對python的不熟悉，導致一開始老師叫我們練習實作Linked List的時候，真的感到很絕望很崩潰，我連python的基本語法都不會，更不用說實作Linked List了，然而這還不是最崩潰的，隨著第一次作業的到來，給我深深的打擊，我能理解老師上課解說的觀念，但實在做不出來，當下真的覺得與其他課程相比這堂課好難好嚴格，當時的心情真的很低落，也感到很大的壓力，但是經過一段時間的努力後，程式越打越順，作業也越寫越快，一開始可能要寫一個禮拜，後來可能一兩天就解決了，這就代表即使是一個程式小白，只要自己肯花時間學習一定也可以學會，付出多少努力就會得到多少成果。<br>

在過去上過的無數課程裡，這堂課應該是我收穫最多也印象最深的課程了，雖然花了很多時間，但在課程結束後，真的感覺自己寫程式的能力提升好多，雖然一開始覺得教授和助教怎麼這麼嚴格，但課程結束後沒有任何怨言只有滿滿的感謝，感謝讓我遇到你們，使我成為一個更好的人，你們真的是很好的老師和助教。👍

## 目錄
[LeetCode](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/Leetcode)\
[Codesignal](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/Codesignal)<br>

**每週課程紀錄：**
* [Week1](#Week1)
* [Week2](#Week2)
  * [Linked List](#linked-list)
     * [課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vTB218-EdUZ5jpNz6Uv4TOZQc37Y281v128_aRcWC6EhkTQs5bS8fh7yysmcuzb9R2QPN6_PDshFWL_/pub?start=false&loop=false&delayms=3000&slide=id.p)
     * [Linked List 程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/01_LeetCode_707.%20Design%20Linked%20List.py)
     * [Array比較](#array比較)
* [Week3](#Week3)
  * [Stack & Queue](#stack--queue)
     * [課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vQ1hb79im0vqpApCttGnXAFRT8SqH9HQP0b_oyVRCV8SVyiHLkHJjidYGAfxkvq468QMumFIDdTeiB-/pub?start=false&loop=false&delayms=3000&slide=id.p)
     * [Stack程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/02_LeetCode_155.%20Min%20Stack.py)
     * [Queue程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/02_LeeCode_232.%20Implement%20Queue%20using%20Stacks.py)
* [Week4](#Week4)
  * [Insertion Sort](#insertion-sort)
     * [課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vQOTMDM-5-OUaGfnLUOFVgefFwSVRplSwnbicp0CXOQrB5H8RM_1Aq8o_4JxHlncEmhjvqk3tzcoB7s/pub?start=false&loop=false&delayms=3000&slide=id.p)
     * [Insertion Sort程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/04_LeeCode_147.%20Insertion%20Sort%20List.py)
  * [Quick Sort](#quick-sort)
     * [課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vSqz8sTxT4xyjgiz-htLvZd7FZ_5ZzgKf60pFEoNLU5S77JxrsGJ2vd15CdxlfLtT3g2aizHP-Ebk9b/pub?start=false&loop=false&delayms=3000&slide=id.p)
     * [老師程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/06_QuickSort_LinkedList.py)
     * [HW1](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW1)
     * [Quick Sort 程式碼](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW_Quick%20Sort/Quick%20Sort.ipynb)
     * [學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW1/Quick%20Sort%20程式碼與學習歷程.ipynb)<br>
     * [過程](#過程)
     * [過程(另外存取空間)](#過程另外存取空間)
* [Week5停課](#Week5)
* [Week6](#Week6)
  * [Heap Sort](#heap-sort)
     * [課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vRAGwnUvg6BcXoML5u9f4gO6YKcz0vXf7bDnPho_S7mG5D0SBR78djt91RKUPMxqNfkVIcu3l5WCXPh/pub?start=false&loop=false&delayms=3000&slide=id.p)
     * [老師程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/06_HeapSort.py)
     * [HW2](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW2)
     * [程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW2/heap_sort_05113009.py)
     * [學習歷程](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW2/heap%20sort%20流程圖、學習歷程與文字說明.pdf)
* [Week7](#Week7)
  * [Merge Sort](#Merge-Sort)
     * [課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vToxkEzc1H1RT5MI9G941KQFBC7GO_Efn95wTqXLEdr3LDBSNcQb-M46IOC-_RzZih6IBEwwy3rWQuE/pub?start=false&loop=false&delayms=3000&slide=id.p)
     * [HW2](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW2)
     * [程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW2/merge_sort_05113009.py)
     * [學習歷程](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW2/merge%20sort%20流程圖、學習歷程與文字說明.pdf)
* [Week8](#Week8)
  * [Binary Tree](#Binary-Tree)
    * [課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vSC3P8sGElP48mJTjqT309470SmTFBwJXWsU9hTX2hg5tVpiG4yC703qA7ibPep-Qakmm2Mw_F-ScZh/pub?start=false&loop=false&delayms=3000&slide=id.g707e8c8328_0_30)
* [Week9](#Week9)
  * [Binary Search Tree](#Binary-Search-Tree)
    * [課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vQgUh73yvSdxAvMH50DHWJ5lsCX8-daMxtoltU9rYW7xCmqYz2A1wOv0Vcx_F9KO5ZUvZBv3IF1TjGi/pub?start=false&loop=false&delayms=3000&slide=id.p)
    * [HW3](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW3)
    * [功能說明](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW3/binary%20search%20tree%20功能說明.ipynb)
    * [程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW3/binary_search_tree_05113009.py)
    * [學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW3/binary%20search%20tree%20學習歷程與流程圖.ipynb)
* [Week10](#Week10)
  * [Red Black Tree](#Red-Black-Tree)
    * [課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vRxyJRARq0BNuGJq_o2cUHIXBWrRSZrAOyXOSt9qCTSjQtyp8XqFq3VuNn3gCt3sXenOZmWLqIjcyFs/pub?start=false&loop=false&delayms=3000&slide=id.p)
    * [老師程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/10_RBT.py)
* [Week11](#Week11)
  * [Hash Table](#Hash-Table)
    * [課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vT1HO9Nl475k2bR0l1x8_Tr4V5Wzx0BEqp9bpmHckvj8kTeJehhYVlOJUDVPhLQm6kjGCJ_sLMSBUw5/pub?start=false&loop=false&delayms=3000&slide=id.p)
    * [HW4](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW4)
    * [程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW4/hash_table_05113009.py)
    * [學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW4/hash%20table%20學習歷程、流程圖與文字說明.ipynb)
* [Week12](#Week12)
  * [Breadth First Search](#Breadth-First-Search)
    * [課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vSYJYXUXvGAeTZ5fknxj_-EPm3zxgy4ITdImrXzy63Y-iZgs8uwVNmOaZlnx9fUNzsbo8kphvMTa0c4/pub?start=false&loop=false&delayms=3000&slide=id.p)
    * [HW5](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW5)
    * [程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW5/BFS_05113009.py)
    * [學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW5/BFS%26DFS_流程圖、學習歷程與原理與比較.ipynb)
* [Week13](#Week13)
  * [Depth First Search](#Depth-First-Search)
    * [課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vTma_vOZyE70O23KWw4I4Y78aAaT5fJSTq7Mae912kCwka_u5ZMWPoo14D86-x-57kZPbb6hAGktSW4/pub?start=false&loop=false&delayms=3000&slide=id.p)
    * [HW5](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW5)
    * [程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW5/BFS_05113009.py)
    * [學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW5/BFS%26DFS_流程圖、學習歷程與原理與比較.ipynb)
* [Week14](#Week14)
  * [Minimum Spanning Tree](#Minimum-Spanning-Tree)
    * [課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vTorNDEyhYA4ZAt5jEqOmFs2cQiUAYvkTp-R0DOn9B3c1MuUecV-a1wNakFIrJxA6AoUFGzbl3OQBIJ/pub?start=false&loop=false&delayms=3000&slide=id.p)
    * [HW6](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW6)
    * [程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW6/Dijkstra_05113009.py)
    * [學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW6/Dijkstra%20%26%20Kruskal%20學習歷程與文字說明.ipynb)
* [Week15](#Week15)
  * [Shortest Path](#Shortest-Path)
    * [課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vTgHO5AkHJS6iN6bnnBMMdHv6E4rabnrC0KwyTRfjad8Ab3IQjbnGvZuQOjDC9t7nKqeroiwcuasJrI/pub?start=false&loop=false&delayms=3000&slide=id.p)
    * [HW6](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW6)
    * [程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW6/Dijkstra_05113009.py)
    * [學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW6/Dijkstra%20%26%20Kruskal%20學習歷程與文字說明.ipynb)
* [Week16](#Week16)
  * [Overview](#Overview)
    * [課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vSkbZghFr5Y3VG3b-BKCZiLNHyhcMIxFmNDHn-tgWQqH4vaGjulKASn_ex_LLDJwxPIRCacGQnBRYrI/pub?start=false&loop=false&delayms=3000&slide=id.p)
* [Week17期末考](#Week17)
* [Week18課程結束](#Week18)
  

# Week1
課程介紹\
[回目錄](#目錄)

# Week2
[課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vTB218-EdUZ5jpNz6Uv4TOZQc37Y281v128_aRcWC6EhkTQs5bS8fh7yysmcuzb9R2QPN6_PDshFWL_/pub?start=false&loop=false&delayms=3000&slide=id.p)

## Linked list
**連結串列**，使用node(節點)來記錄、表示、儲存資料，並利用pointer指向下一個node，以達到node之間的串接，並以NULL為終點。\
將node串接起來後，每一個node裡面都有紀錄下一個node的位子，因此我們可以進行**新增節點、刪除節點、走訪節點及取得節點內的資料**等操作。\
但是若我們要擷取的資料不是在第一個node的話，就必須從第一個開始走訪到我們要找的位置，所以需要***花費較長的時間與較大的記憶體處理***。
[Linked List 程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/01_LeetCode_707.%20Design%20Linked%20List.py)
<br>
<br>

![](https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/LinkedList/Intro/f2.png?raw=true)
[圖面來源](http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html)
<br>
<br>

### Array比較
優點：
  * 可直接使用index
  * 較節省記憶體，不需要pointer來處理資料，
  * ***與Linked List相比較有效率***
  
缺點：
  * 新增刪除很麻煩
  * 只要移動一個，就全部都要移動
  
適合使用時機：
  * 要快速存取資料
  * 已知矩陣大小、資料數量
  * 記憶體空間要求小

[回目錄](#目錄)

# Week3
[課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vQ1hb79im0vqpApCttGnXAFRT8SqH9HQP0b_oyVRCV8SVyiHLkHJjidYGAfxkvq468QMumFIDdTeiB-/pub?start=false&loop=false&delayms=3000&slide=id.p)
## Stack & Queue
### Stack
Stack（堆疊）為一種資料結構，可以用 Array 或是 Linked List 的形式來操作，Stack的特性為「先進後出，後進先出」，就如同籃子一樣，越晚放進去的東西會放在越上面，所以上面的東西得先拿出來，最下面的東西才有可能拿出來。<br>
[Stack程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/02_LeetCode_155.%20Min%20Stack.py)


#### Stack 功能：<br>
* Push(data)：把資料放進Stack。
* Pop：把「最上面」的資料從Stack中移除。
* Top：回傳「最上面」的資料，不影響資料結構本身。
* IsEmpty：確認Stack裡是否有資料，不影響資料結構本身。
* getSize：回傳Stack裡的資料個數，不影響資料結構本身。
<img src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Stack/intro/f1.png?raw=true" >
<br>

[參考資料](http://alrightchiu.github.io/SecondRound/stack-introjian-jie.html)

### Queue
Queue（佇列）為一種資料結構，可以用 Array 或是 Linked List 的形式來操作，Queue的特性為「先進先出，後進後出」，就如同排隊一樣，先來的人就可以先買東西，後來的人就要等前面的人都買完了才可以買。<br>
[Queue程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/02_LeeCode_232.%20Implement%20Queue%20using%20Stacks.py)


#### Queue 功能：
* Push(data)：把資料從Queue的「後面」放進Queue，並更新成新的back。
* Pop：把front所指向的資料從Queue中移除，並更新front。
* getFront：回傳front所指向的資料。
* getBack：回傳back所指向的資料。
* IsEmpty：確認Queue裡是否有資料。
* getSize：回傳Queue裡的資料個數。
<img src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/BasicDataStructures/Queue/intro/queue.gif?raw=true">
<br>

[參考資料](http://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html)\
[回目錄](#目錄)

# Week4
[Insertion Sort課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vQOTMDM-5-OUaGfnLUOFVgefFwSVRplSwnbicp0CXOQrB5H8RM_1Aq8o_4JxHlncEmhjvqk3tzcoB7s/pub?start=false&loop=false&delayms=3000&slide=id.p)
[Quick Sort課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vSqz8sTxT4xyjgiz-htLvZd7FZ_5ZzgKf60pFEoNLU5S77JxrsGJ2vd15CdxlfLtT3g2aizHP-Ebk9b/pub?start=false&loop=false&delayms=3000&slide=id.p)
 * [老師程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/06_QuickSort_LinkedList.py)


## Insertion Sort
**插入排序法**,想像手上有一副撲克牌，若想要將紙牌從左到右按照「小到大」排序。\
Insertion Sort的方法為：將第i張紙牌加入「前i−1張排序過」的紙牌組合，得到i張排序過的紙牌組合。
<br>
[Insertion Sort程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/04_LeeCode_147.%20Insertion%20Sort%20List.py)


時間複雜度  | Quick Sort | Heap Sort | Merge Sort | Insertion Sort | Seletion Sort| 
-------------|------------|-----------|------------|----------------|--------------|
Best Case    | NlogN      |NlogN |NlogN |N|N^2
Average Case | NlogN      |NlogN |NlogN |N^2|N^2
Worst Case   | N^2        |NlogN |NlogN |N^2|N^2
<br>

[參考資料](http://alrightchiu.github.io/SecondRound/comparison-sort-insertion-sortcha-ru-pai-xu-fa.html)\
[回目錄](#目錄)


## Quick Sort
**快速排序法**，先決定取一個固定的位子為pivot，再依序將其餘的數值與pivot比大小，將比pivot小的都丟掉左邊，比pivot大的都丟到右邊。 再來將比pivot小的那些數值再比一次大小，並一樣取第一個為pivot，比pivot大的也用同樣的方式處理，直到不能再處理，亦即所有數值都依照大小都排好了。
<br>

[HW1](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW1)\
[Quick Sort 程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW1/Quick_Sort_05113009.py)\
[學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW1/Quick%20Sort%20程式碼與學習歷程.ipynb)<br>


### 過程
['54',26,93,17,77,31,44,55,20] --> list[left]=93, list[right]=20 --> 交換位置變成['54',26,20,17,77,31,44,55,93] --> list[left]=77, list[right]=44 -->交換位置變成['54',26,20,17,44,31,77,55,93] --> list[left]=77, list[right]=31 --> right < left --> pivot與list[right]交換值 --> [31,26,20,17,44,'54' ,77,55,93] 

-->第一次排序完成，接著再將小於54的數列依照此法排序，大於54的數列也是如此，最後就會得出依照大小排序好的 [17, 20, 26, 31, 44, 54, 55, 77, 93]

<img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/圖/Quick%20Sort%20Demo.jpg" width="50%">

### 過程(另外存取空間)
>['54',26,93,17,77,31,44,55,20] --> small=[26,17,31,44,20] , big=[93,77,55] , pivotlist=[54] 
>>['26',17,31,44,20] --> small=[17,20] , big=[31,44] , pivotlist=[26] --> return small + pivotlist + big --> [17,20,26,31,44] 
>>['93',77,55] --> small=[77,55] , big=[] , pivotlist=[93] <br/>
>>>['77',55] --> small=[55] , big=[] , pivotlist=[77] --> [55,77]
>>>>[55,77,93]

return small + pivotlist + big --> [17, 20, 26, 31, 44, 54, 55, 77, 93]
<br>

[回目錄](#目錄)


# Week5
雙十連假停課一次\
[回目錄](#目錄)

# Week6
## Heap Sort
[課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vRAGwnUvg6BcXoML5u9f4gO6YKcz0vXf7bDnPho_S7mG5D0SBR78djt91RKUPMxqNfkVIcu3l5WCXPh/pub?start=false&loop=false&delayms=3000&slide=id.p)\
[老師程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/06_HeapSort.py)

### ***以陣列的形式表現，但要以二元樹的方式理解。***
* 子節點不得比父節點大，若子節點較大，則與父節點換位
* 比較後，最頂端的父節點為此數列的最大值，將其取出放入暫存空間 
* 取出最大值後，再進行一次比較排序
* 直到將所有數值由大到小都取出後，數列即完成排序
<br>

時間複雜度  | Quick Sort | Heap Sort | Merge Sort | Insertion Sort | Seletion Sort| 
-------------|------------|-----------|------------|----------------|--------------|
Best Case    | NlogN      |NlogN |NlogN |N|N^2
Average Case | NlogN      |NlogN |NlogN |N^2|N^2
Worst Case   | N^2        |NlogN |NlogN |N^2|N^2
<br>

[HW2](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW2)\
[程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW2/heap_sort_05113009.py)\
[學習歷程](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW2/heap%20sort%20流程圖、學習歷程與文字說明.pdf)
<br>

![](https://algorithm.yuanbin.me/shared-files/images/Heapsort-example.gif)
[圖片來源](https://algorithm.yuanbin.me/zh-tw/basics_data_structure/heap.html)

  * python index:i
    * left:2i+1
    * right:2i+2
<br>  

<img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/圖/heap%20sort%20圖.png" width="50%">
<br>

[參考資料](http://notepad.yehyeh.net/Content/Algorithm/Sort/Heap/Heap.php)\
[回目錄](#目錄)
    
# Week7  
[課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vToxkEzc1H1RT5MI9G941KQFBC7GO_Efn95wTqXLEdr3LDBSNcQb-M46IOC-_RzZih6IBEwwy3rWQuE/pub?start=false&loop=false&delayms=3000&slide=id.p)

## Merge Sort
* 把數列對半拆解，直到每個數列都只剩一個數值
* 將拆解好的數列倆倆做比較，比較後再做合併
* 依此類推，直到所有數列都合併成一個數列，即完成排序

時間複雜度  | Quick Sort | Heap Sort | Merge Sort | Insertion Sort | Seletion Sort| 
-------------|------------|-----------|------------|----------------|--------------|
Best Case    | NlogN      |NlogN |NlogN |N|N^2
Average Case | NlogN      |NlogN |NlogN |N^2|N^2
Worst Case   | N^2        |NlogN |NlogN |N^2|N^2
<br>

[HW2](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW2)\
[程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW2/merge_sort_05113009.py)\
[學習歷程](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW2/merge%20sort%20流程圖、學習歷程與文字說明.pdf)
<br>

<img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/圖/merge%20sort%20圖.png" width="50%">
<br>

[參考資料](https://alrightchiu.github.io/SecondRound/comparison-sort-merge-sorthe-bing-pai-xu-fa.html)\
[回目錄](#目錄)

# Week8
[課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vSC3P8sGElP48mJTjqT309470SmTFBwJXWsU9hTX2hg5tVpiG4yC703qA7ibPep-Qakmm2Mw_F-ScZh/pub?start=false&loop=false&delayms=3000&slide=id.g707e8c8328_0_30)

## Binary Tree
最廣義的樹(Tree)對於樹上的node之child數目沒有限制，因此，每個node可以有多個child。\
若限制node只能有兩個child，等價於「樹上的每一個node之degree皆為2」，此即稱為Binary Tree(二元樹)，並稱兩個child pointer為left child和right child。
<br>

<img src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/f2.png?raw=true">
<br>

[參考資料](http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html)\
[回目錄](#目錄)

# Week9
[課堂投影片](https://docs.google.com/presentation/d/e/2PACX-1vQgUh73yvSdxAvMH50DHWJ5lsCX8-daMxtoltU9rYW7xCmqYz2A1wOv0Vcx_F9KO5ZUvZBv3IF1TjGi/pub?start=false&loop=false&delayms=3000&slide=id.p)

## Binary Search Tree
BST為二元樹，亦即每一個節點底下都只能有兩個子節點，BST與Binary Tree最大的差別在於有大小順序，Binary Tree每一個節點底下最多只能有兩個子節點，這點與BST一樣，不過Binary Tree的任意子節點可以大於、等於或小於父節點，但BST不行，BST需要透過比較大小進行搜尋排序等等動作，也正是因為有這項特徵，所以方便我們尋找資料，不需要走訪過每一個節點。
<br>

Binary Search Tree:
* 每個節點底下最多只會有兩個子節點
* 需比較大小，非數值型資料，則可以新增編號等等，以便排序
* 有一定的排序規則：
        - 比節點小的放左邊
        - 比節點大的放右邊
        - 與節點相等的可放左或右邊，不過要統一（自行定義）
<br>

[HW3](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW3)\
[功能說明](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW3/binary%20search%20tree%20功能說明.ipynb)<br>
[程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW3/binary_search_tree_05113009.py)<br>
[學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW3/binary%20search%20tree%20學習歷程與流程圖.ipynb)
<br>

<img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/Binary%20Search%20Tree/delete%20流程圖.jpg" width="50%"><img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/Binary%20Search%20Tree/insert流程圖.jpg" width="50%">
<img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/Binary%20Search%20Tree/modify流程圖.jpg" width="50%"><img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/Binary%20Search%20Tree/search流程圖.jpg" width="50%">
<br>

[參考資料](http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html)\
[回目錄](#目錄)

# Week10
[課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vRxyJRARq0BNuGJq_o2cUHIXBWrRSZrAOyXOSt9qCTSjQtyp8XqFq3VuNn3gCt3sXenOZmWLqIjcyFs/pub?start=false&loop=false&delayms=3000&slide=id.p)\
[老師程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/class/10_RBT.py)
## Red Black Tree
Red Black Tree(RBT)是node塗了「顏色」的Binary Search Tree(BST)，藉由控制顏色，能夠保證在RBT中，最長path(路徑)不會超過最短path的兩倍，若最短的path是5，最長的path至多只能是10，如此RBT便能夠近似地視為平衡。\
平衡方法：改顏色、左旋轉、右旋轉

Red Black Tree 規則：
* 節點為紅或黑色
* root一定要為黑色
* 紅節點只能接黑色，黑色可以接紅色和黑色
* 每個空節點為黑色
* 從root到leaf的每條路徑所包含的黑點要相同

<img src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/f4.png?raw=true" width="70%">
<br>

[參考資料](https://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html)\
[回目錄](#目錄)


# Week11
[課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vT1HO9Nl475k2bR0l1x8_Tr4V5Wzx0BEqp9bpmHckvj8kTeJehhYVlOJUDVPhLQm6kjGCJ_sLMSBUw5/pub?start=false&loop=false&delayms=3000&slide=id.p)

## Hash Table
* Hash Function 是將輸入的值轉譯成另外的值，特性為快速、單向性、不可逆性，只有輸入的值能得到輸出的值，輸出的值無法反向得到輸入的值。且好的Hash Function 不易出現碰撞，所以當出現碰撞卻沒抑制的話，會使資料更難查詢。<br>
* Hash Table 是一種儲存(key,value)的資料結構，一個key對應一個value，key可以想像成標籤，要找到這筆value就必須要有key才找得到。Table size 若是太小會使資料太過集中，導致查詢效率降低，因此Table size的設定就非常重要。<br>
* Hash 時間複雜度： O(1)     <      ( *array: O(n), binary search tree: O(logn)~O(n)* )<br>
* Chaining概念：可能有不同的資料分配到同一組，所以用linked list將其都串在一起，可以解決碰撞問題。

在Hash Function設計不良的狀況下，有可能會都分到同一組，導致連接很長的linked list，這樣就失去Hash的優勢了，並且可能會發生碰撞，所以為了減少這種狀況的發生，可以使用Cryptographic Hash Function，利用加密的方式來避免碰撞的發生，所以一般都會使用Cryptographic Hash Function的方法，Cryptographic Hash Function有很多不同的演算法，其中包含常見的MD5、SHA等，除此之外，還可以提高Table size，使資料分佈的更分散且平均，以減少碰撞發生。
<br>

Hash常用於：搜尋引擎、檔案校對碼、使用者密碼儲存比對。<br>
只需要將使用者輸入的密碼hash過後再進行比對，也可以將不公開的密碼加密後存入Hash Table裡，這樣既可以比對密碼是否正確，也可防止密碼外洩的可能性。<br>

Hash功能：新增、刪除、查詢
<br>

[HW4](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW4)\
[程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW4/hash_table_05113009.py)<br>
[學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW4/hash%20table%20學習歷程、流程圖與文字說明.ipynb)<br>

<img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/圖/hash_add.png" width="70%"> 
<img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/圖/hash_contains.png" width="70%"> 
<img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/圖/hash_remove.png" width="70%"> 
<br>

[參考資料](http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html)\
[回目錄](#目錄)


# Week12
[課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vSYJYXUXvGAeTZ5fknxj_-EPm3zxgy4ITdImrXzy63Y-iZgs8uwVNmOaZlnx9fUNzsbo8kphvMTa0c4/pub?start=false&loop=false&delayms=3000&slide=id.p)

## Breadth First Search
**廣度/橫向優先搜尋**，為廣義的Level-Order Traversal，將使用情境從Tree推廣至Graph，先走訪所有相鄰的節點，再以剛剛走訪的節點當作下一次搜尋的起點，搜尋相鄰的所有節點，逐一走訪，直至所有節點都走訪為止。以Tree來說明，就是將同一深度(level)的所有節點都走訪完才會進到下一個深度，直到所有節點都被尋訪過。<br>
BFS屬於盲目搜索(uninformed search)是利用佇列(Queue)來處理，確保先被走訪到的節點會優先成為新的搜尋起點(先進先出)。<br>

[HW5](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW5)\
[程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW5/BFS_05113009.py)<br>
[學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW5/BFS%26DFS_流程圖、學習歷程與原理與比較.ipynb)<br>

<img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/圖/bfs.png" width="70%"> 
<br>

[參考資料](https://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html)\
[回目錄](#目錄)


# Week13
[課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vTma_vOZyE70O23KWw4I4Y78aAaT5fJSTq7Mae912kCwka_u5ZMWPoo14D86-x-57kZPbb6hAGktSW4/pub?start=false&loop=false&delayms=3000&slide=id.p)

## Depth First Search
**深度/縱向優先搜尋**，是從某一節點出發後，遇到還未走訪的相鄰節點則走訪，直到沒有未走訪的相鄰節點可搜尋，則退回前一個節點尋找是否有還未走訪的節點，直至所有節點都被走訪為止。 <br>
DFS屬於盲目搜索(uninformed search)是利用堆疊(Stack)來處理，確保先遇到的鄰點就先走訪(後進先出)。<br>

[HW5](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW5)\
[程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW5/BFS_05113009.py)<br>
[學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW5/BFS%26DFS_流程圖、學習歷程與原理與比較.ipynb)<br>

<img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/圖/dfs.png" width="70%"> 
<br>

[參考資料](https://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html)
[回目錄](#目錄)


# Week14
[課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vTorNDEyhYA4ZAt5jEqOmFs2cQiUAYvkTp-R0DOn9B3c1MuUecV-a1wNakFIrJxA6AoUFGzbl3OQBIJ/pub?start=false&loop=false&delayms=3000&slide=id.p)

## Minimum Spanning Tree
Kruskal演算法是一種用來尋找無向圖中最小生成樹（Minimum Spanning Tree）的演算法，亦即找出圖中邊權重最小的樹，且每個點都要包含在其中，但不需要考慮root應該為哪個點、樹是否有平衡或是樹高大小等等，只需要找出最小權重總和的樹即可。用來解決同樣問題的還有前面Prim演算法和Boruvka演算法等，和Boruvka演算法不同的地方是，Kruskal演算法在圖中存在相同權重的邊時也有效。

    1. 先把每個節點都當成一棵樹
    2. 再來排序所有邊的權重，由小到大（最小生成樹）
    3. 若兩節點分別為不同的樹，此條邊則為MST的邊
    4. 反之若為同一顆樹，連結此邊會產生loop，因此應該捨去這條邊    
    
    *** 可能不只有一個解，只要權重為最小即可
    時間複雜度：O(ElogE)或者O(ElogV)
[程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW6/Dijkstra_05113009.py)\
[學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW6/Dijkstra%20%26%20Kruskal%20學習歷程與文字說明.ipynb)
<br>

<img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/圖/Kruskal.png" width="70%"> <br>

[參考資料](http://www.csie.ntnu.edu.tw/~u91029/SpanningTree.html)\
[參考資料](http://www.csie.ntnu.edu.tw/~u91029/SpanningTree.html)\
[回目錄](#目錄)

# Week15
[課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vTgHO5AkHJS6iN6bnnBMMdHv6E4rabnrC0KwyTRfjad8Ab3IQjbnGvZuQOjDC9t7nKqeroiwcuasJrI/pub?start=false&loop=false&delayms=3000&slide=id.p)

## Shortest Path
Dijkstra演算法為指定一個點到其他點的最短路徑（單源最短路徑-Shortest Path），最簡單的執行方法就是將每個節點在不經過其他節點的情況下，到其他節點的權重(weight/cost)儲存在串列或陣列裡，因此有幾個節點就需要進行多少次搜尋，時間複雜度為O(V²)。

<br>

    1. 先將所有節點到其他節點（不經過其他節點）的權重存到串列或陣列中，若是無法到達則紀錄∞
    2. 選定起點(a)，將(a)能到達的點之權重先加入最短路徑中，並找出串列或陣列中距離最近的點(b)，並確定為最短路徑
    3. 從(a)->(b)->？，將(b)能走到的點之權重加入（a->b->c的權重總和），若為已尋訪過的節點則判斷（a->b->c）是否
       小於（a->c），如果小於則更新最短路徑的權重，最後再找出未確定節點中距離最近的點。
    4. 重複執行步驟3，直到全部都確定為起點到任一點的最短路徑為止。
    
    時間複雜度：O(V²)   V:節點個數
[HW6](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/tree/master/HW6)\
[程式碼](https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW6/Dijkstra_05113009.py)\
[學習歷程](https://nbviewer.jupyter.org/github/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/HW6/Dijkstra%20%26%20Kruskal%20學習歷程與文字說明.ipynb)
<br>

<img src="https://github.com/jiaying777/DATA-STRUCTURES-AND-ALGORITHMS/blob/master/圖/Dijkstra.png" width="70%"><br>

[參考資料](http://nthucad.cs.nthu.edu.tw/~yyliu/personal/nou/04ds/dijkstra.html)\
[回目錄](#目錄)


# Week16
[課程投影片](https://docs.google.com/presentation/d/e/2PACX-1vSkbZghFr5Y3VG3b-BKCZiLNHyhcMIxFmNDHn-tgWQqH4vaGjulKASn_ex_LLDJwxPIRCacGQnBRYrI/pub?start=false&loop=false&delayms=3000&slide=id.p)

## Overview
同學分享實作區塊鏈與期末講解\
[回目錄](#目錄)

# Week17
期末考\
[回目錄](#目錄)

# Week18
課程已結束\
[回目錄](#目錄)
